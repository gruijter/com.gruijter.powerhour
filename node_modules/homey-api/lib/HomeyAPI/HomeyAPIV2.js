'use strict';

const SocketIOClient = require('socket.io-client');

const Manager = require('./HomeyAPIV2/Manager');
const ManagerApps = require('./HomeyAPIV2/ManagerApps');
const ManagerDevices = require('./HomeyAPIV2/ManagerDevices');
const HomeyAPI = require('./HomeyAPI');
const HomeyAPIError = require('./HomeyAPIError');
const APIErrorHomeyOffline = require('../APIErrorHomeyOffline');
const Util = require('../Util');

/**
 * This class is returned by {@link AthomCloudAPI.Homey#authenticate} for a Homey with firmware `>=2.0.0`.
 *
 * @class
 * @hideconstructor
 * @extends HomeyAPI
 */
class HomeyAPIV2 extends HomeyAPI {

  static MANAGERS = {
    ManagerApps,
    ManagerDevices,
  };

  constructor({
    properties,
    strategy = [
      HomeyAPI.DISCOVERY_STRATEGIES.MDNS,
      HomeyAPI.DISCOVERY_STRATEGIES.CLOUD,
      HomeyAPI.DISCOVERY_STRATEGIES.LOCAL,
      HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE,
      HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED,
    ],
    ...props
  }) {
    super({ properties, ...props });

    Object.defineProperty(this, '__baseUrl', {
      value: null,
      enumerable: false,
      writable: true,
    });

    Object.defineProperty(this, '__strategyId', {
      value: null,
      enumerable: false,
      writable: true,
    });

    Object.defineProperty(this, '__token', {
      value: null,
      enumerable: false,
      writable: true,
    });

    Object.defineProperty(this, '__strategies', {
      value: Array.isArray(strategy)
        ? strategy
        : [strategy],
      enumerable: false,
      writable: false,
    });

    Object.defineProperty(this, '__managers', {
      value: {},
      enumerable: false,
      writable: false,
    });

    Object.defineProperty(this, '__baseUrlPromise', {
      value: null,
      enumerable: false,
      writable: true,
    });

    Object.defineProperty(this, '__loginPromise', {
      value: null,
      enumerable: false,
      writable: true,
    });

    Object.defineProperty(this, '__connected', {
      value: false,
      enumerable: false,
      writable: true,
    });

    this.generateManagersFromSpecification();
  }

  /*
   * Get the Homey's base URL promise
   */
  get baseUrl() {
    return (async () => {
      if (!this.__baseUrlPromise) {
        this.__baseUrlPromise = this.discoverBaseUrl().then(({ baseUrl }) => baseUrl);
        this.__baseUrlPromise.catch(() => { });
      }

      return this.__baseUrlPromise;
    })();
  }

  get strategyId() {
    return this.__strategyId;
  }

  /*
   * Generate Managers from JSON specification
   * A manager instance is created when it's first accessed
   */

  getSpecification() {
    // eslint-disable-next-line global-require
    return require('../../assets/specifications/HomeyAPIV2.json');
  }

  generateManagersFromSpecification() {
    const { managers } = this.getSpecification();
    Object.entries(managers).forEach(([managerName, manager]) => {
      this.generateManagerFromSpecification(managerName, manager);
    });
  }

  generateManagerFromSpecification(managerName, manager) {
    Object.defineProperty(this, manager.idCamelCase, {
      get: () => {
        if (!this.__managers[managerName]) {
          // eslint-disable-next-line global-require, import/no-dynamic-require
          const ManagerClass = this.constructor.MANAGERS[managerName]
            ? this.constructor.MANAGERS[managerName]
            : Manager;

          this.__managers[managerName] = new ManagerClass({
            homey: this,
            id: manager.id,
            name: managerName,
            items: manager.items || {},
            operations: manager.operations || {},
          });
        }

        return this.__managers[managerName];
      },
      enumerable: false,
    });
  }

  /*
   * Discover the URL to talk to Homey
   * We prefer localSecure, because it's fastest and most secure
   * If that doesn't work, we prefer local OR mdns, whichever is fastest
   * Finally, we fallback to cloud
   */

  async discoverBaseUrl() {
    const urls = {};

    if (this.__strategies.includes(HomeyAPI.DISCOVERY_STRATEGIES.MDNS)) {
      if (Util.isHTTPUnsecureSupported()) {
        urls[HomeyAPI.DISCOVERY_STRATEGIES.MDNS] = `http://homey-${this.id}.local`;
      }
    }

    if (this.__strategies.includes(HomeyAPI.DISCOVERY_STRATEGIES.LOCAL)) {
      if (Util.isHTTPUnsecureSupported() && this.__properties.localUrl) {
        urls[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL] = `${this.__properties.localUrl}`;
      }
    }

    if (this.__strategies.includes(HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE)) {
      if (this.__properties.localUrlSecure) {
        urls[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE] = `${this.__properties.localUrlSecure}`;
      }
    }

    if (this.__strategies.includes(HomeyAPI.DISCOVERY_STRATEGIES.CLOUD)) {
      if (this.__properties.remoteUrl) {
        urls[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD] = `${this.__properties.remoteUrl}`;
      }
    }

    if (this.__strategies.includes(HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED)) {
      if (this.__properties.remoteUrlForwarded) {
        urls[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED] = `${this.__properties.remoteUrlForwarded}`;
      }
    }

    if (!Object.keys(urls).length) {
      throw new Error('No Discovery Strategies Available');
    }

    // Don't discover, just set the only strategy
    if (Object.keys(urls).length === 1) {
      this.__baseUrl = Object.values(urls)[0];
      this.__strategyId = Object.keys(urls)[0];

      return {
        baseUrl: this.__baseUrl,
        strategyId: this.__strategyId,
      };
    }

    this.__debug(`Discovery Strategies: ${Object.keys(urls).join(',')}`);

    // Create the returned Promise
    let resolve;
    let reject;
    const promise = new Promise((resolve_, reject_) => {
      resolve = resolve_;
      reject = reject_;
    });
    promise
      .then(({ baseUrl, strategyId }) => {
        this.__baseUrl = baseUrl;
        this.__strategyId = strategyId;
      })
      .catch(() => { });

    // Ping method
    const ping = async (strategyId, timeout) => {
      let pingTimeout;
      const baseUrl = urls[strategyId];
      return Promise.race([
        Util.fetch(`${baseUrl}/api/manager/system/ping?id=${this.id}`, {
          headers: {
            'X-Homey-ID': this.id,
          },
        }).then(async res => {
          const text = await res.text();
          if (!res.ok) throw new Error(text || res.statusText);
          if (text === 'false') throw new Error('Invalid Homey ID');

          const homeyId = res.headers.get('X-Homey-ID');
          if (homeyId) {
            if (homeyId !== this.id) throw new Error('Invalid Homey ID'); // TODO: Add to Homey Connect
          }

          // Set the version that Homey told us.
          // It's the absolute truth, because the Cloud API may be behind.
          const homeyVersion = res.headers.get('X-Homey-Version');
          if (homeyVersion !== this.version) {
            this.version = homeyVersion;
          }

          return {
            baseUrl,
            strategyId,
          };
        }),
        new Promise((_, reject) => {
          pingTimeout = setTimeout(() => reject(new Error('PingTimeout')), timeout);
        }),
      ]).finally(() => clearTimeout(pingTimeout));
    };

    const pings = {};

    // Ping localSecure (https://xxx-xxx-xxx-xx.homey.homeylocal.com)
    if (urls[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE] = ping(HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE, 1200);
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE].catch(err => this.__debug(`Ping ${HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE} Error:`, err && err.message));
    }

    // Ping local (http://xxx-xxx-xxx-xxx)
    if (urls[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL] = ping(HomeyAPI.DISCOVERY_STRATEGIES.LOCAL, 1000);
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL].catch(err => this.__debug(`Ping ${HomeyAPI.DISCOVERY_STRATEGIES.LOCAL} Error:`, err && err.message));
    }

    // Ping mdns (http://homey-<homeyId>.local)
    if (urls[HomeyAPI.DISCOVERY_STRATEGIES.MDNS]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS] = ping(HomeyAPI.DISCOVERY_STRATEGIES.MDNS, 3000);
      pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS].catch(err => this.__debug(`Ping ${HomeyAPI.DISCOVERY_STRATEGIES.MDNS} Error:`, err && err.message));
    }

    // Ping cloud (https://<homeyId>.connect.athom.com)
    if (urls[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD] = ping(HomeyAPI.DISCOVERY_STRATEGIES.CLOUD, 5000);
      pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD].catch(err => this.__debug(`Ping ${HomeyAPI.DISCOVERY_STRATEGIES.CLOUD} Error:`, err && err.message));
    }

    // Ping Direct (https://xxx-xxx-xxx-xx.homey.homeylocal.com:12345)
    if (urls[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED] = ping(HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED, 2000);
      pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED].catch(err => this.__debug(`Ping ${HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED} Error:`, err && err.message));
    }

    // Select the best route
    if (pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL_SECURE]
        .then(result => resolve(result))
        .catch(() => {
          const promises = [];

          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL]) {
            promises.push(pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL]);
          }

          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED]) {
            promises.push(pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED]);
          }

          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS]) {
            promises.push(pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS]);
          }

          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
            promises.push(pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]);
          }

          if (!promises.length) {
            throw new APIErrorHomeyOffline();
          }

          return Util.promiseAny(promises);
        })
        .then(result => resolve(result))
        .catch(() => reject(new APIErrorHomeyOffline()));
    } else if (pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.LOCAL]
        .then(result => resolve(result))
        .catch(() => {
          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
            pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]
              .then(result => resolve(result))
              .catch(err => reject(new APIErrorHomeyOffline(err)));
          }
        });
    } else if (pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.MDNS]
        .then(result => resolve(result))
        .catch(() => {
          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
            pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]
              .then(result => resolve(result))
              .catch(err => reject(new APIErrorHomeyOffline(err)));
          }
        });
    } else if (pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.REMOTE_FORWARDED]
        .then(result => resolve(result))
        .catch(() => {
          if (pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
            pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]
              .then(result => resolve(result))
              .catch(err => reject(new APIErrorHomeyOffline(err)));
          }
        });
    } else if (pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]) {
      pings[HomeyAPI.DISCOVERY_STRATEGIES.CLOUD]
        .then(result => resolve(result))
        .catch(err => reject(new APIErrorHomeyOffline(err)));
    } else {
      reject(new APIErrorHomeyOffline());
    }

    return promise;
  }

  async call({
    $timeout = 10000,
    method,
    headers,
    path,
    body,
    retryAfterRefresh = false,
  }) {
    const baseUrl = await this.baseUrl;

    method = method.toUpperCase();

    headers = {
      ...headers,
      'X-Homey-ID': this.id,
    };

    if (body) {
      headers['Content-Type'] = 'application/json';
    }

    if (this.__token) {
      headers['Authorization'] = `Bearer ${this.__token}`;
    }

    this.__debug(method, `${baseUrl}${path}`);
    const res = await Util.timeout(Util.fetch(`${baseUrl}${path}`, {
      method,
      headers,
      body: ['PUT', 'POST'].includes(method) && typeof body !== 'undefined'
        ? JSON.stringify(body)
        : undefined,
    }), $timeout);

    const resStatusCode = res.status;
    if (resStatusCode === 204) return undefined;

    const resStatusText = res.status;
    const resHeadersContentType = res.headers.get('Content-Type');
    const resBodyText = await res.text();
    let resBodyJson;
    if (resHeadersContentType && resHeadersContentType.startsWith('application/json')) {
      try {
        resBodyJson = JSON.parse(resBodyText);
      } catch (err) { }
    }

    if (!res.ok) {
      if (resBodyJson) {
        // If Session Expired, clear the stored token
        if (resStatusCode === 401) {
          this.__debug('Session expired, invalidating token...');
          await this.logout();
        }

        // If Session Expired, try to refresh the Token
        if (resStatusCode === 401 && !retryAfterRefresh) {
          this.__debug('Session expired, refreshing...');
          await this.login();
          return this.call({
            method,
            headers,
            path,
            body,
            retryAfterRefresh: true,
          });
        }

        throw new HomeyAPIError({
          error: resBodyJson.error,
          error_description: resBodyJson.error_description,
          stack: resBodyJson.stack,
        }, resStatusCode);
      }

      if (resBodyText) {
        throw new HomeyAPIError({
          error: resBodyText,
        }, resStatusCode);
      }

      throw new HomeyAPIError({
        error: resStatusText,
      }, resStatusCode);
    }

    if (typeof resBodyJson !== 'undefined') {
      return resBodyJson;
    }

    return resBodyText;
  }

  async login() {
    if (!this.__loginPromise) {
      this.__loginPromise = Promise.resolve().then(async () => {
        // Check store for a valid Homey.Session
        const store = await this.__getStore();
        if (store && store.token) {
          this.__debug('Got token from store');
          return store.token;
        }

        // Create a Session by generating a JWT token on AthomCloudAPI,
        // and then sending the JWT token to Homey.
        this.__debug('Retrieving token...');
        const jwtToken = await this.__api.createDelegationToken({ audience: 'homey' });
        const token = await this.users.login({
          $socket: false,
          token: jwtToken,
        });
        await this.__setStore({ token });
        this.__debug('Got token');

        return token;
      });

      this.__loginPromise
        .then(token => {
          this.__token = token;
        })
        .catch(err => {
          this.__debug('Error Logging In:', err);
        })
        .finally(() => {
          this.__loginPromise = null;
        });
    }

    return this.__loginPromise;
  }

  async logout() {
    await this.__setStore({
      token: null,
    });

    this.__token = null;
  }

  /**
   * If Homey is connected to Socket.io.
   * @returns {Boolean}
   */
  isConnected() {
    return this.__connected === true;
  }

  async subscribe(uri, {
    onConnect = () => { },
    onReconnect = () => { },
    onReconnectError = () => { },
    onDisconnect = () => { },
    onEvent = () => { },
  }) {
    this.__debug('subscribe', uri);

    await this.connect();
    await new Promise((resolve, reject) => {
      this.__ioNamespace.once('disconnect', reject);
      this.__ioNamespace.emit('subscribe', uri, err => {
        if (err) return reject(err);
        return resolve();
      });
    });

    // On Connect
    const __onEvent = (event, data) => {
      onEvent(event, data);
    };
    this.__ioNamespace.on(uri, __onEvent);

    onConnect();

    // On Disconnect
    const __onDisconnect = reason => {
      onDisconnect(reason);
    };
    this.__io.on('disconnect', __onDisconnect);

    // On Reconnect
    const __onReconnect = () => {
      Promise.resolve().then(async () => {
        await this.connect();
        await new Promise((resolve, reject) => {
          this.__ioNamespace.emit('subscribe', uri, err => {
            if (err) return reject(err);
            return resolve();
          });
        });

        this.__ioNamespace.on(uri, __onEvent);

        onReconnect();
      }).catch(err => onReconnectError(err));
    };
    this.__io.on('reconnect', __onReconnect);

    return {
      unsubscribe: () => {
        this.__ioNamespace.emit('unsubscribe', uri);
        this.__ioNamespace.removeListener(uri, __onEvent);
        this.__io.removeListener('disconnect', __onDisconnect);
        this.__io.removeListener('reconnect', __onReconnect);
      },
    };
  }

  async connect() {
    if (!this.io) {
      this.io = Promise.resolve().then(async () => {
        // Ensure Base URL
        const baseUrl = await this.baseUrl;

        // Ensure Token
        if (!this.__token) await this.login();

        return new Promise((resolve, reject) => {
          this.__debug(`SocketIOClient ${baseUrl}`);
          this.__io = SocketIOClient(baseUrl, {
            autoConnect: false,
            transports: ['websocket'],
            transportOptions: {
              pingTimeout: 8000,
              pingInterval: 5000,
            },
          });
          this.__io.on('disconnect', reason => {
            this.__debug('SocketIOClient.onDisconnect', reason);
            this.__connected = false;

            if (this.__ioNamespace) {
              this.__ioNamespace.disconnect();
              this.__ioNamespace.destroy();
              this.__ioNamespace.removeAllListeners();
            }

            reject(new Error('Disconnected'));
          });
          this.__io.on('error', err => {
            this.__debug('SocketIOClient.onError', err.message);
          });
          this.__io.on('reconnect', () => {
            this.__debug('SocketIOClient.onReconnect');
            this.__handshakeClient()
              .then(() => {
                this.__debug('SocketIOClient.onReconnect.onHandshakeClientSuccess');
                this.__connected = true;
                resolve();
              })
              .catch(err => {
                this.__debug('SocketIOClient.onReconnect.onHandshakeClientError', err.message);
                reject(err);
              });
          });
          this.__io.on('reconnecting', attempt => {
            this.__debug(`SocketIOClient.onReconnecting (Attempt #${attempt})`);
          });
          this.__io.on('reconnect_error', err => {
            this.__debug('SocketIOClient.onReconnectError', err.message);
          });
          this.__io.once('connect_error', err => {
            this.__debug('SocketIOClient.onConnectError', err.message);
            reject(err);
          });
          this.__io.once('connect', () => {
            this.__debug('SocketIOClient.onConnect');
            this.__handshakeClient()
              .then(() => {
                this.__debug('SocketIOClient.onConnect.onHandshakeClientSuccess');
                this.__connected = true;
                resolve();
              })
              .catch(err => {
                this.__debug('SocketIOClient.onConnect.onHandshakeClientError', err.message);
                reject(err);
              });
          });
          this.__io.connect();
        });
      });
      this.io.catch(err => {
        this.__debug('SocketIOClient Error', err.message);
      });
    }

    return this.io;
  }

  async disconnect() {
    if (this.__io) {
      await new Promise(resolve => {
        this.__io.once('disconnect', resolve());
        this.__io.disconnect();
        this.__io.removeAllListeners();
        this.__io = null;
      });
    }
    // TODO todo what?
  }

  destroy() {
    if (this.__io) {
      this.__io.removeAllListeners();
      this.__io.close();
    }
  }

  async __handshakeClient() {
    return new Promise((resolve, reject) => {
      this.__io.emit('handshakeClient', {
        token: this.__token,
        homeyId: this.id,
      }, (err, result) => {
        if (err) return reject(err);
        return resolve(result);
      });
    })
      .catch(async err => {
        // If token is expired, try to refresh
        if (err.statusCode === 401) {
          this.__debug('Token expired, refreshing...');
          await this.logout();
          await this.login();

          return new Promise((resolve, reject) => {
            this.__io.emit('handshakeClient', {
              token: this.__token,
              homeyId: this.id,
            }, (err, result) => {
              if (err) return reject(err);
              return resolve(result);
            });
          });
        }

        throw err;
      })
      .then(({ namespace }) => {
        this.__debug('SocketIOClient.onHandshakeClientSuccess', `Namespace: ${namespace}`);

        return new Promise((resolve, reject) => {
          this.__ioNamespace = this.__io.io.socket(namespace);
          this.__ioNamespace.once('connect', () => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onConnect`);
            resolve();
          });
          this.__ioNamespace.once('connect_error', err => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onConnectError`, err.message);
            reject(err);
          });
          this.__ioNamespace.on('reconnecting', attempt => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onReconnecting (Attempt #${attempt})`);
          });
          this.__ioNamespace.on('reconnect', () => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onReconnect`);
          });
          this.__ioNamespace.on('reconnect_error', err => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onReconnectError`, err.message);
          });
          this.__ioNamespace.on('disconnect', reason => {
            this.__debug(`SocketIOClient.Namespace[${namespace}].onDisconnect`, reason);
          });
          this.__ioNamespace.connect();
        });
      });
  }

}

module.exports = HomeyAPIV2;
